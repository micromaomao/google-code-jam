<!DOCTYPE html><html><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../commons/style.css"><script src="../commons/general.js" async></script><title>2020-1A Problem A - Mao's Google Code Jam practice files</title><link rel="stylesheet" href="../commons/hljs.css"></head><body><a class="toroot" href="..">Return to problem list</a><h1>2020-1A Problem A</h1><h2>Other files</h2><div class="filehead"><div class="fnamecontain"><a class="fname" href="files/brute_force/main.rs" target="_blank">brute_force/main.rs</a>:</div><a class="download" href="files/brute_force/main.rs" title="Download original" download="main.rs">save</a>&nbsp;&nbsp;&nbsp;<a class="openongithub" href="https://github.com/micromaomao/google-code-jam/blob/master/2020-1A/1/brute_force/main.rs" target="_blank">open on GitHub</a></div><pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">solve</span></span>(_patterns: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;) -&gt; <span class="hljs-built_in">String</span> {
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> patterns: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Vec</span>&lt;PatternItem&gt;&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(_patterns.len());
	<span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PatternItem</span></span> {
		EndStar,
		Item(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">char</span>)
	}
	<span class="hljs-keyword">for</span> pattern <span class="hljs-keyword">in</span> _patterns.into_iter() {
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> pat = <span class="hljs-built_in">Vec</span>::with_capacity(pattern.len());
		<span class="hljs-keyword">let</span> chars: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">char</span>&gt; = pattern.chars().collect();
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> i = <span class="hljs-number">0usize</span>;
		<span class="hljs-keyword">while</span> i &lt; chars.len() {
			<span class="hljs-keyword">let</span> c = chars[i];
			<span class="hljs-keyword">if</span> c == <span class="hljs-string">'*'</span> {
				<span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &lt; chars.len() &amp;&amp; chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span> {
					i += <span class="hljs-number">1</span>;
					<span class="hljs-keyword">continue</span>;
				}
				<span class="hljs-keyword">if</span> i == chars.len() - <span class="hljs-number">1</span> {
					pat.push(PatternItem::EndStar);
					i += <span class="hljs-number">1</span>;
				} <span class="hljs-keyword">else</span> {
					pat.push(PatternItem::Item(<span class="hljs-literal">true</span>, chars[i + <span class="hljs-number">1</span>]));
					i += <span class="hljs-number">2</span>;
				}
			} <span class="hljs-keyword">else</span> {
				pat.push(PatternItem::Item(<span class="hljs-literal">false</span>, chars[i]));
				i += <span class="hljs-number">1</span>;
			}
		}
		patterns.push(pat);
	}

	<span class="hljs-keyword">use</span> std::collections::HashSet;
	<span class="hljs-meta">#[derive(Hash, PartialEq, Eq, Clone, Debug)]</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span></span> {
		prefix: <span class="hljs-built_in">String</span>,
		at_pattern_positions: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">usize</span>&gt;
	}

	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current_states = HashSet::new();
	current_states.insert(State{
		prefix: <span class="hljs-built_in">String</span>::new(),
		at_pattern_positions: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0usize</span>; patterns.len()]
	});


	<span class="hljs-keyword">loop</span> {
		<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(end_state) = current_states.iter().find(|s| {
			<span class="hljs-keyword">for</span> (i, pos) <span class="hljs-keyword">in</span> s.at_pattern_positions.iter().enumerate() {
				<span class="hljs-keyword">let</span> pos = *pos;
				<span class="hljs-keyword">let</span> pat = &amp;patterns[i];
				<span class="hljs-keyword">if</span> pos &gt;= pat.len() {
					<span class="hljs-keyword">continue</span>;
				}
				<span class="hljs-keyword">if</span> pat[pos] != PatternItem::EndStar {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			}
			<span class="hljs-literal">true</span>
		}) {
			<span class="hljs-keyword">return</span> end_state.prefix.to_owned();
		}

		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> possible_next_letters = HashSet::new();
		<span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> current_states.iter() {
			<span class="hljs-keyword">for</span> (i, pos) <span class="hljs-keyword">in</span> s.at_pattern_positions.iter().enumerate() {
				<span class="hljs-keyword">let</span> pos = *pos;
				<span class="hljs-keyword">let</span> pat = &amp;patterns[i];
				<span class="hljs-keyword">if</span> pos == pat.len() {
					<span class="hljs-keyword">continue</span>;
				}
				<span class="hljs-keyword">match</span> pat[pos] {
					PatternItem::Item(_, c) =&gt; {
						possible_next_letters.insert(c);
					},
					PatternItem::EndStar =&gt; {}
				};
			}
		}

		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> new_states = HashSet::new();

		<span class="hljs-symbol">'s</span>: <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> current_states.iter() {
			<span class="hljs-keyword">for</span> advance_char <span class="hljs-keyword">in</span> possible_next_letters.iter().map(|x| *x) {
				<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> allow_star_patterns: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">Vec</span>&lt;PatternItem&gt;&gt; = <span class="hljs-built_in">Vec</span>::new();
				<span class="hljs-keyword">for</span> (i, pos) <span class="hljs-keyword">in</span> s.at_pattern_positions.iter().enumerate() {
					<span class="hljs-keyword">let</span> pos = *pos;
					<span class="hljs-keyword">let</span> pat = &amp;patterns[i];
					<span class="hljs-keyword">if</span> pos &gt;= pat.len() {
						<span class="hljs-keyword">continue</span> <span class="hljs-symbol">'s</span>;
					}
					<span class="hljs-keyword">match</span> pat[pos] {
						PatternItem::Item(allow_star, _) =&gt; {
							<span class="hljs-keyword">if</span> allow_star {
								allow_star_patterns.push(pat);
							}
						},
						PatternItem::EndStar =&gt; {}
					}
				}

				<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> new_prefix = s.prefix.clone();
				new_prefix.push(advance_char);

				<span class="hljs-symbol">'a</span>: <span class="hljs-keyword">for</span> pred <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..(<span class="hljs-number">1u64</span> &lt;&lt; (allow_star_patterns.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u64</span>)) {
					<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> new_poss = <span class="hljs-built_in">Vec</span>::with_capacity(s.at_pattern_positions.len());
					<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> every_pattern_stared = <span class="hljs-literal">true</span>;
					<span class="hljs-keyword">for</span> (i, pos) <span class="hljs-keyword">in</span> s.at_pattern_positions.iter().enumerate() {
						<span class="hljs-keyword">let</span> pos = *pos;
						<span class="hljs-keyword">let</span> pat = &amp;patterns[i];
						<span class="hljs-keyword">if</span> pos &gt;= pat.len() {
							<span class="hljs-keyword">continue</span>;
						}
						<span class="hljs-keyword">match</span> pat[pos] {
							PatternItem::Item(allow_star, c) =&gt; {
								<span class="hljs-keyword">if</span> allow_star {
									<span class="hljs-keyword">let</span> idx = allow_star_patterns.iter().position(|x| x == &amp;pat).unwrap();
									<span class="hljs-keyword">if</span> (pred &gt;&gt; idx) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> {
										<span class="hljs-comment">// follow star</span>
										new_poss.push(pos)
									} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> advance_char == c {
										new_poss.push(pos + <span class="hljs-number">1</span>);
										every_pattern_stared = <span class="hljs-literal">false</span>;
									} <span class="hljs-keyword">else</span> {
										<span class="hljs-keyword">continue</span> <span class="hljs-symbol">'a</span>;
									}
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> advance_char == c {
									new_poss.push(pos + <span class="hljs-number">1</span>);
									every_pattern_stared = <span class="hljs-literal">false</span>;
								} <span class="hljs-keyword">else</span> {
									<span class="hljs-keyword">continue</span> <span class="hljs-symbol">'a</span>;
								}
							},
							PatternItem::EndStar =&gt; {
								new_poss.push(pos);
							}
						}
					}

					<span class="hljs-built_in">assert_eq!</span>(new_poss.len(), patterns.len());

					<span class="hljs-keyword">if</span> !every_pattern_stared {
						new_states.insert(State{
							prefix: new_prefix.clone(),
							at_pattern_positions: new_poss
						});
					}
				}
			}
		}

		current_states = new_states;
		<span class="hljs-keyword">if</span> current_states.len() == <span class="hljs-number">0</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-string">"*"</span>.to_owned();
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
	<span class="hljs-keyword">let</span> t: <span class="hljs-built_in">usize</span> = {
		<span class="hljs-keyword">let</span> l = read_ints();
		<span class="hljs-built_in">assert_eq!</span>(l.len(), <span class="hljs-number">1</span>);
		l[<span class="hljs-number">0</span>]
	};
	<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..t {
		<span class="hljs-keyword">let</span> n: <span class="hljs-built_in">usize</span> = {
			<span class="hljs-keyword">let</span> l = read_ints();
			<span class="hljs-built_in">assert_eq!</span>(l.len(), <span class="hljs-number">1</span>);
			l[<span class="hljs-number">0</span>]
		};
		<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> patterns: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(n);
		<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
			patterns.push(read_line());
		}
		<span class="hljs-built_in">println!</span>(<span class="hljs-string">"Case #{}: {}"</span>, c + <span class="hljs-number">1</span>, solve(patterns));
	}
}

<span class="hljs-comment">// boilerplate omitted...</span></code></pre></body></html>