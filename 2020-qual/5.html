<!DOCTYPE html><html><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../commons/style.css"><script src="../commons/general.js" async></script><title>2020-qual Problem E - Mao's Google Code Jam practice files</title><link rel="stylesheet" href="../commons/hljs.css"></head><body><a class="toroot" href="..">Return to problem list</a><h1>2020-qual Problem E</h1><h2>Final solution</h2><div class="filehead"><div class="fnamecontain"><a class="fname" href="files/main.rs" target="_blank">main.rs</a>:</div><a class="download" href="files/main.rs" title="Download original" download="main.rs">save</a>&nbsp;&nbsp;&nbsp;<a class="openongithub" href="https://github.com/micromaomao/google-code-jam/blob/master/2020-qual/5/main.rs" target="_blank">open on GitHub</a></div><pre><code class="hljs"><span class="hljs-keyword">use</span> std::collections::HashSet;
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bipartite_match</span></span>(m: <span class="hljs-built_in">usize</span>, n: <span class="hljs-built_in">usize</span>, connections: &amp;[(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)]) -&gt; HashSet&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)&gt; {
  <span class="hljs-built_in">debug_assert!</span>(connections.iter().collect::&lt;HashSet&lt;_&gt;&gt;().len() == connections.len());

  <span class="hljs-meta">#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]</span>
  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Node</span></span> {
    Left(<span class="hljs-built_in">usize</span>),
    Right(<span class="hljs-built_in">usize</span>)
  }

  <span class="hljs-keyword">impl</span> Node {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_left</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> &amp;Node::Left(_) = <span class="hljs-keyword">self</span> {
        <span class="hljs-literal">true</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">false</span>
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_right</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> &amp;Node::Right(_) = <span class="hljs-keyword">self</span> {
        <span class="hljs-literal">true</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">false</span>
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span> {
      <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {
        Node::Left(n) =&gt; n,
        Node::Right(n) =&gt; n
      }
    }
  }

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ltor = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">Vec</span>::new(); m];
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rtol = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">Vec</span>::new(); n];
  <span class="hljs-keyword">for</span> &amp;(l, r) <span class="hljs-keyword">in</span> connections.iter() {
    <span class="hljs-keyword">if</span> l &gt;= m || r &gt;= n {
      <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"invalid input."</span>);
    }

    ltor[l].push(r);
    rtol[r].push(l);
  }

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current_matches: HashSet&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)&gt; = HashSet::new();

  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">aug_can_go</span></span>(from: &amp;Node, to: &amp;Node, current_matches: &amp;HashSet&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)&gt;) -&gt; <span class="hljs-built_in">bool</span> {
    <span class="hljs-keyword">if</span> from.is_left() &amp;&amp; to.is_right() {
      !current_matches.contains(&amp;(from.index(), to.index()))
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> from.is_right() &amp;&amp; to.is_left() {
      current_matches.contains(&amp;(to.index(), from.index()))
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">unreachable!</span>()
    }
  }

  <span class="hljs-keyword">loop</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> l_matched: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">bool</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-literal">false</span>; m];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r_matched: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">bool</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-literal">false</span>; n];
    <span class="hljs-keyword">for</span> &amp;(i, j) <span class="hljs-keyword">in</span> current_matches.iter() {
      l_matched[i] = <span class="hljs-literal">true</span>;
      r_matched[j] = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dfs</span></span>(
      n: Node,
      ltor: &amp;[<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">usize</span>&gt;], rtol: &amp;[<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">usize</span>&gt;],
      current_match: &amp;HashSet&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>)&gt;,
      r_matched: &amp;[<span class="hljs-built_in">bool</span>],
      visited: &amp;<span class="hljs-keyword">mut</span> HashSet&lt;Node&gt;
    ) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;Node&gt;&gt; {
      <span class="hljs-built_in">assert!</span>(visited.insert(n));
      <span class="hljs-keyword">if</span> n.is_right() &amp;&amp; !r_matched[n.index()] {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>(<span class="hljs-built_in">vec!</span>[n]);
      }
      <span class="hljs-keyword">let</span> next_hops: <span class="hljs-built_in">Vec</span>&lt;Node&gt; = <span class="hljs-keyword">match</span> n {
        Node::Left(i) =&gt; ltor[i].iter().map(|j| Node::Right(*j)).collect(),
        Node::Right(i) =&gt; rtol[i].iter().map(|j| Node::Left(*j)).collect(),
      };
      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> next_hops {
        <span class="hljs-keyword">if</span> aug_can_go(&amp;n, &amp;j, current_match) &amp;&amp; !visited.contains(&amp;j) {
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">mut</span> path) = dfs(j, ltor, rtol, current_match, r_matched, visited) {
            path.push(n);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>(path);
          }
        }
      }
      <span class="hljs-literal">None</span>
    }
    <span class="hljs-keyword">let</span> dfs_path = (<span class="hljs-number">0</span>..m).into_iter()
      .filter(|i| !l_matched[*i])
      .map(|i| dfs(Node::Left(i), &amp;ltor, &amp;rtol, &amp;current_matches, &amp;r_matched, &amp;<span class="hljs-keyword">mut</span> HashSet::new()))
      .find(|x| x.is_some()).map(|x| x.unwrap());
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">mut</span> path) = dfs_path {
      path.reverse();
      <span class="hljs-built_in">debug_assert!</span>(path.len() &gt;= <span class="hljs-number">2</span>);
      <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> path.windows(<span class="hljs-number">2</span>) {
        <span class="hljs-keyword">let</span> (i, j) = (w[<span class="hljs-number">0</span>], w[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">match</span> i {
          Node::Left(i) =&gt; {
            <span class="hljs-built_in">debug_assert!</span>(j.is_right());
            current_matches.insert((i, j.index()));
          },
          Node::Right(i) =&gt; {
            <span class="hljs-built_in">debug_assert!</span>(j.is_left());
            <span class="hljs-built_in">assert!</span>(current_matches.remove(&amp;(j.index(), i)));
          }
        }
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">break</span>;
    }
  }

  current_matches
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decompose_abc</span></span>(n: <span class="hljs-built_in">i32</span>, k: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)&gt; {
  <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..(n+<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..(n+<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">let</span> c = k - b - a*(n-<span class="hljs-number">2</span>);
      <span class="hljs-keyword">if</span> c &lt; <span class="hljs-number">1</span> || c &gt; n {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (a == b &amp;&amp; a != c) || (a == c &amp;&amp; a != b) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span> &amp;&amp; b == c &amp;&amp; a != b {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-built_in">debug_assert_eq!</span>(a*(n-<span class="hljs-number">2</span>)+b+c, k);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>((a, b, c))
    }
  }
  <span class="hljs-literal">None</span>
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">solve</span></span>(n: <span class="hljs-built_in">i32</span>, k: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;&gt; {
  <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> {
      <span class="hljs-literal">Some</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>])
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-literal">None</span>
    };
  }
  <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span> k {
      <span class="hljs-number">2</span> =&gt; <span class="hljs-literal">Some</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]),
      <span class="hljs-number">4</span> =&gt; <span class="hljs-literal">Some</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]),
      _ =&gt; <span class="hljs-literal">None</span>
    };
  }

  <span class="hljs-keyword">match</span> decompose_abc(n, k) {
    <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,
    <span class="hljs-literal">Some</span>((a, b, c)) =&gt; {
      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> mat = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0i32</span>; (n*n) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>];
      mat[<span class="hljs-number">0</span>] = b;
      mat[n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>+<span class="hljs-number">1</span>] = c;
      <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">2</span>..n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> {
        mat[x*n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>+x] = a;
      }

      <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> connections = <span class="hljs-built_in">Vec</span>::with_capacity((n*n) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> {
          <span class="hljs-keyword">if</span> mat[y*n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>+x] != <span class="hljs-number">0</span> {
            connections.push((x, mat[y*n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>+x] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>));
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> allowed = <span class="hljs-built_in">vec!</span>[<span class="hljs-literal">true</span>; (n+<span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>];
            allowed[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> {
              allowed[mat[y*n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>+x] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>] = <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> {
              <span class="hljs-keyword">if</span> allowed[a] {
                connections.push((x, a));
              }
            }
          }
        }
        <span class="hljs-keyword">let</span> m = bipartite_match(n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>, (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>, &amp;connections);
        <span class="hljs-built_in">assert_eq!</span>(m.len(), n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">for</span> (x, nb) <span class="hljs-keyword">in</span> m {
          <span class="hljs-keyword">let</span> nb = nb <span class="hljs-keyword">as</span> <span class="hljs-built_in">i32</span>;
          mat[y * n <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> + x] = nb;
        }
      }

      <span class="hljs-literal">Some</span>(mat)
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">use</span> std::fmt::Write;

  <span class="hljs-keyword">let</span> t = read_ints()[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..t {
    <span class="hljs-keyword">let</span> (n, k) = {
      <span class="hljs-keyword">let</span> l = read_ints();
      (l[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>])
    };
    <span class="hljs-keyword">let</span> mat = solve(n, k);
    <span class="hljs-keyword">let</span> possible = mat.is_some();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Case #{}: {}"</span>, i + <span class="hljs-number">1</span>, <span class="hljs-keyword">if</span> possible { <span class="hljs-string">"POSSIBLE"</span> } <span class="hljs-keyword">else</span> { <span class="hljs-string">"IMPOSSIBLE"</span> });
    <span class="hljs-keyword">if</span> possible {
      <span class="hljs-keyword">let</span> mat = mat.unwrap();
      <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> line = <span class="hljs-built_in">String</span>::new();
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n {
          <span class="hljs-keyword">if</span> x != <span class="hljs-number">0</span> {
            <span class="hljs-built_in">write!</span>(line, <span class="hljs-string">" "</span>);
          }
          <span class="hljs-built_in">write!</span>(line, <span class="hljs-string">"{}"</span>, mat[(y*n+x) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>]);
        }
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, line);
      }
    }
  }
}

<span class="hljs-comment">// boilerplate omitted...</span></code></pre></body></html>