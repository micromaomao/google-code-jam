<!DOCTYPE html><html><head><meta charset="utf8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../commons/style.css"><script src="../commons/general.js" async></script><title>2019-qual Problem D - Mao's Google Code Jam practice files</title><link rel="stylesheet" href="../commons/hljs.css"></head><body><a class="toroot" href="..">Return to problem list</a><h1>2019-qual Problem D</h1><h2>Final solution</h2><div class="filehead"><div class="fnamecontain"><a class="fname" href="files/cmd.go" target="_blank">cmd.go</a>:</div><a class="download" href="files/cmd.go" title="Download original" download="cmd.go">save</a>&nbsp;&nbsp;&nbsp;<a class="openongithub" href="https://github.com/micromaomao/google-code-jam/blob/master/2019-qual/4/cmd.go" target="_blank">open on GitHub</a></div><pre><code class="hljs"><span class="hljs-comment">// package, import, etc...</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> t <span class="hljs-keyword">int</span>
	mustReadLineOfInts(&amp;t)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t; i++ {
		<span class="hljs-keyword">var</span> _N, _B, _F <span class="hljs-keyword">int</span>
		mustReadLineOfInts(&amp;_N, &amp;_B, &amp;_F)
		F := <span class="hljs-keyword">uint</span>(_F)
		N := <span class="hljs-keyword">uint</span>(_N)
		B := <span class="hljs-keyword">uint</span>(_B)
		workerNumbers := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint</span>, N)
		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>); i &lt; N; i++ {
			workerNumbers[i] = i % (<span class="hljs-number">1</span> &lt;&lt; F)
		}
		gotNumbers := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint</span>, N-B)
		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>); i &lt; F; i++ {
			<span class="hljs-keyword">for</span> w := <span class="hljs-number">0</span>; w &lt; <span class="hljs-built_in">len</span>(workerNumbers); w++ {
				<span class="hljs-keyword">if</span> (workerNumbers[w]&gt;&gt;i)&amp;<span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> {
					stdout.WriteByte(<span class="hljs-string">'1'</span>)
				} <span class="hljs-keyword">else</span> {
					stdout.WriteByte(<span class="hljs-string">'0'</span>)
				}
			}
			stdout.WriteByte(<span class="hljs-string">'\n'</span>)
			stdout.Flush()
			response := mustReadLine()
			<span class="hljs-keyword">if</span> response == <span class="hljs-string">"-1"</span> {
				os.Exit(<span class="hljs-number">0</span>)
			} <span class="hljs-keyword">else</span> {
				assert(<span class="hljs-keyword">uint</span>(<span class="hljs-built_in">len</span>(response)) == N-B)
				<span class="hljs-keyword">for</span> r := <span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>); r &lt; N-B; r++ {
					<span class="hljs-keyword">switch</span> response[r] {
					<span class="hljs-keyword">case</span> <span class="hljs-string">'0'</span>:
						<span class="hljs-comment">// do nothing</span>
					<span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:
						gotNumbers[r] += <span class="hljs-number">1</span> &lt;&lt; i
					}
				}
			}
		}
		indices := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">uint</span>, <span class="hljs-number">0</span>, B)
		pointToRsp := <span class="hljs-number">0</span>
		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>); i &lt; N; i++ {
			<span class="hljs-keyword">if</span> pointToRsp &lt; <span class="hljs-built_in">len</span>(gotNumbers) &amp;&amp; gotNumbers[pointToRsp] == workerNumbers[i] {
				pointToRsp++
				<span class="hljs-keyword">continue</span>
			} <span class="hljs-keyword">else</span> {
				indices = <span class="hljs-built_in">append</span>(indices, i)
			}
		}
		assert(<span class="hljs-built_in">len</span>(indices) == <span class="hljs-keyword">int</span>(B))
		<span class="hljs-keyword">for</span> i, id := <span class="hljs-keyword">range</span> indices {
			<span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> {
				stdout.WriteByte(<span class="hljs-string">' '</span>)
			}
			stdout.WriteString(strconv.Itoa(<span class="hljs-keyword">int</span>(id)))
		}
		stdout.WriteByte(<span class="hljs-string">'\n'</span>)
		stdout.Flush()
		verdict := mustReadLine()
		<span class="hljs-keyword">if</span> verdict == <span class="hljs-string">"-1"</span> {
			os.Exit(<span class="hljs-number">0</span>)
		}
	}
}

<span class="hljs-comment">// boilerplate omitted...</span></code></pre><h2>Solution that only works for the small input</h2><div class="filehead"><div class="fnamecontain"><a class="fname" href="files/small/cmd.go" target="_blank">small/cmd.go</a>:</div><a class="download" href="files/small/cmd.go" title="Download original" download="cmd.go">save</a>&nbsp;&nbsp;&nbsp;<a class="openongithub" href="https://github.com/micromaomao/google-code-jam/blob/master/2019-qual/4/small/cmd.go" target="_blank">open on GitHub</a></div><pre><code class="hljs"><span class="hljs-comment">/*
 THIS SOLUTION IS THE ONE I SUBMITTED DURING THE ROUND AND DID NOT PASS THE HIDDEN TEST!
*/</span>

<span class="hljs-comment">// package, import, etc...</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> t <span class="hljs-keyword">int</span>
	mustReadLineOfInts(&amp;t)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t; i++ {
		result := round()
		wrote := <span class="hljs-literal">false</span>
		<span class="hljs-keyword">for</span> _, seg := <span class="hljs-keyword">range</span> result {
			<span class="hljs-keyword">if</span> seg.numBad == seg.length {
				<span class="hljs-keyword">for</span> p := seg.start; p &lt; seg.start+seg.length; p++ {
					<span class="hljs-keyword">if</span> wrote {
						stdout.WriteByte(<span class="hljs-string">' '</span>)
					}
					stdout.WriteString(strconv.Itoa(p))
					wrote = <span class="hljs-literal">true</span>
				}
			}
		}
		stdout.WriteByte(<span class="hljs-string">'\n'</span>)
		stdout.Flush()
		<span class="hljs-keyword">var</span> verdict <span class="hljs-keyword">int</span>
		mustReadLineOfInts(&amp;verdict)
		<span class="hljs-keyword">if</span> verdict != <span class="hljs-number">1</span> {
			<span class="hljs-keyword">return</span>
		}
	}
}

<span class="hljs-keyword">type</span> Seg <span class="hljs-keyword">struct</span> {
	start           <span class="hljs-keyword">int</span>
	length          <span class="hljs-keyword">int</span>
	numBad          <span class="hljs-keyword">int</span>
	test_interlaced <span class="hljs-keyword">bool</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(seg Seg)</span> <span class="hljs-title">solved</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> {
	<span class="hljs-keyword">return</span> seg.length == seg.numBad || seg.numBad == <span class="hljs-number">0</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">round</span><span class="hljs-params">()</span> []<span class="hljs-title">Seg</span></span> {
	<span class="hljs-keyword">var</span> nWorkers, nBad, qLimit, qUsed <span class="hljs-keyword">int</span>
	mustReadLineOfInts(&amp;nWorkers, &amp;nBad, &amp;qLimit)
	<span class="hljs-keyword">var</span> segments = <span class="hljs-built_in">make</span>([]Seg, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
	segments = <span class="hljs-built_in">append</span>(segments, Seg{
		start:  <span class="hljs-number">0</span>,
		length: nWorkers,
		numBad: nBad,
	})
	<span class="hljs-keyword">for</span> {
		allSolved := <span class="hljs-literal">true</span>
		query := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, nWorkers)
		<span class="hljs-keyword">for</span> segI := <span class="hljs-number">0</span>; segI &lt; <span class="hljs-built_in">len</span>(segments); segI++ {
			seg := &amp;segments[segI]
			<span class="hljs-keyword">if</span> seg.solved() {
				<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; seg.length; i++ {
					query = <span class="hljs-built_in">append</span>(query, <span class="hljs-number">0</span>)
				}
			} <span class="hljs-keyword">else</span> {
				allSolved = <span class="hljs-literal">false</span>
				<span class="hljs-keyword">if</span> seg.numBad != <span class="hljs-number">1</span> {
					mid := seg.length / <span class="hljs-number">2</span>
					<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; mid; i++ {
						query = <span class="hljs-built_in">append</span>(query, <span class="hljs-number">1</span>)
					}
					<span class="hljs-keyword">for</span> i := mid; i &lt; seg.length; i++ {
						query = <span class="hljs-built_in">append</span>(query, <span class="hljs-number">0</span>)
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-comment">// interlaced: 10101010</span>
					next1 := <span class="hljs-literal">true</span>
					<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; seg.length; i++ {
						<span class="hljs-keyword">if</span> next1 {
							query = <span class="hljs-built_in">append</span>(query, <span class="hljs-number">1</span>)
						} <span class="hljs-keyword">else</span> {
							query = <span class="hljs-built_in">append</span>(query, <span class="hljs-number">0</span>)
						}
						next1 = !next1
					}
					seg.test_interlaced = <span class="hljs-literal">true</span>
				}
			}
		}
		<span class="hljs-keyword">if</span> allSolved {
			<span class="hljs-keyword">return</span> segments
		}
		<span class="hljs-keyword">if</span> qUsed &gt;= qLimit {
			<span class="hljs-keyword">return</span> segments <span class="hljs-comment">// -.-</span>
		}
		qUsed++
		<span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> query {
			<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {
				stdout.WriteByte(<span class="hljs-string">'0'</span>)
			} <span class="hljs-keyword">else</span> {
				stdout.WriteByte(<span class="hljs-string">'1'</span>)
			}
		}
		stdout.WriteByte(<span class="hljs-string">'\n'</span>)
		stdout.Flush()
		response := mustReadLine()
		<span class="hljs-keyword">if</span> response == <span class="hljs-string">"-1"</span> {
			<span class="hljs-keyword">return</span> segments <span class="hljs-comment">// Something's wrong.</span>
		}
		<span class="hljs-keyword">var</span> index <span class="hljs-keyword">int</span>
		newSegments := <span class="hljs-built_in">make</span>([]Seg, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(segments)*<span class="hljs-number">2</span>)
		<span class="hljs-keyword">for</span> _, seg := <span class="hljs-keyword">range</span> segments {
			relevantRes := response[index : index+seg.length-seg.numBad]
			index += <span class="hljs-built_in">len</span>(relevantRes)
			<span class="hljs-keyword">if</span> seg.solved() {
				newSegments = <span class="hljs-built_in">append</span>(newSegments, seg)
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !seg.test_interlaced {
				leftLen := seg.length / <span class="hljs-number">2</span>
				<span class="hljs-comment">// 11110000</span>
				<span class="hljs-keyword">var</span> num1s <span class="hljs-keyword">int</span>
				<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> relevantRes {
					<span class="hljs-keyword">if</span> r == <span class="hljs-string">'1'</span> {
						num1s++
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">break</span>
					}
				}
				segLeft := Seg{
					start:  seg.start,
					length: leftLen,
					numBad: leftLen - num1s,
				}
				segRight := Seg{
					start:  seg.start + leftLen,
					length: seg.length - leftLen,
					numBad: seg.numBad - segLeft.numBad,
				}
				newSegments = <span class="hljs-built_in">append</span>(newSegments, segLeft, segRight)
			} <span class="hljs-keyword">else</span> {
				next1 := <span class="hljs-literal">true</span>
				<span class="hljs-keyword">var</span> skippedPos <span class="hljs-keyword">int</span>
				<span class="hljs-keyword">for</span> skippedPos = <span class="hljs-number">0</span>; skippedPos &lt; <span class="hljs-built_in">len</span>(relevantRes); skippedPos++ {
					<span class="hljs-keyword">if</span> !next1 == (relevantRes[skippedPos] == <span class="hljs-string">'0'</span>) {
						next1 = !next1
						<span class="hljs-keyword">continue</span>
					}
					<span class="hljs-keyword">break</span>
				}
				<span class="hljs-comment">// 1010101</span>
				<span class="hljs-comment">// 101 101</span>
				<span class="hljs-comment">// skippedPos = 3</span>
				<span class="hljs-keyword">if</span> skippedPos &gt; <span class="hljs-number">0</span> {
					newSegments = <span class="hljs-built_in">append</span>(newSegments, Seg{
						start:  seg.start,
						length: skippedPos,
						numBad: <span class="hljs-number">0</span>,
					})
				}
				newSegments = <span class="hljs-built_in">append</span>(newSegments, Seg{
					start:  seg.start + skippedPos,
					length: <span class="hljs-number">1</span>,
					numBad: <span class="hljs-number">1</span>,
				})
				<span class="hljs-keyword">if</span> skippedPos &lt; seg.length<span class="hljs-number">-1</span> {
					newSegments = <span class="hljs-built_in">append</span>(newSegments, Seg{
						start:  seg.start + skippedPos + <span class="hljs-number">1</span>,
						length: seg.length - skippedPos - <span class="hljs-number">1</span>,
					})
				}
			}
		}
		segments = newSegments
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeAndFlush</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span> {
	stdout.WriteString(str)
	stdout.Flush()
}

<span class="hljs-comment">// boilerplate omitted...</span></code></pre></body></html>